{
    "problem_name": "rotting_oranges",
    "solution_class_name": "Solution",
    "problem_number": "994",
    "problem_title": "Rotting Oranges",
    "difficulty": "Medium",
    "topics": "Array, Breadth-First Search, Matrix",
    "tags": ["grind-75"],
    "readme_description": "You are given an `m x n` `grid` where each cell can have one of three values:\n\n- `0` representing an empty cell,\n- `1` representing a fresh orange, or\n- `2` representing a rotten orange.\n\nEvery minute, any fresh orange that is **4-directionally adjacent** to a rotten orange becomes rotten.\n\nReturn *the minimum number of minutes that must elapse until no cell has a fresh orange*. If *this is impossible, return* `-1`.",
    "readme_examples": [
        {
            "content": "![Example 1](https://assets.leetcode.com/uploads/2019/02/16/oranges.png)\n\n```\nInput: grid = [[2,1,1],[1,1,0],[0,1,1]]\nOutput: 4\n```"
        },
        {
            "content": "```\nInput: grid = [[2,1,1],[0,1,1],[1,0,1]]\nOutput: -1\n```\n**Explanation:** The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally."
        },
        {
            "content": "```\nInput: grid = [[0,2]]\nOutput: 0\n```\n**Explanation:** Since there are already no fresh oranges at minute 0, the answer is just 0."
        }
    ],
    "readme_constraints": "- `m == grid.length`\n- `n == grid[i].length`\n- `1 <= m, n <= 10`\n- `grid[i][j]` is `0`, `1`, or `2`.",
    "readme_additional": "",
    "solution_imports": "",
    "solution_methods": [
        {
            "name": "oranges_rotting",
            "parameters": "grid: list[list[int]]",
            "return_type": "int",
            "dummy_return": "0"
        }
    ],
    "test_imports": "import pytest\nfrom leetcode_py.test_utils import logged_test\nfrom .solution import Solution",
    "test_class_name": "TestRottingOranges",
    "test_helper_methods": [
        { "name": "setup_method", "parameters": "", "body": "self.solution = Solution()" }
    ],
    "test_methods": [
        {
            "name": "test_oranges_rotting",
            "parametrize": "grid, expected",
            "parametrize_typed": "grid: list[list[int]], expected: int",
            "test_cases": "[([[2, 1, 1], [1, 1, 0], [0, 1, 1]], 4), ([[2, 1, 1], [0, 1, 1], [1, 0, 1]], -1), ([[0, 2]], 0), ([[0]], 0), ([[1]], -1), ([[2]], 0), ([[1, 2]], 1), ([[2, 1]], 1), ([[0, 1, 2]], 1), ([[2, 2], [1, 1], [0, 0]], 1), ([[2, 1, 1], [1, 1, 1], [0, 1, 2]], 2)]",
            "body": "result = self.solution.oranges_rotting(grid)\nassert result == expected"
        }
    ],
    "playground_imports": "from solution import Solution",
    "playground_test_case": "# Example test case\ngrid = [[2, 1, 1], [1, 1, 0], [0, 1, 1]]\nexpected = 4",
    "playground_execution": "result = Solution().oranges_rotting(grid)\nresult",
    "playground_assertion": "assert result == expected"
}
