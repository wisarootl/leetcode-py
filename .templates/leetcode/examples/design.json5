{
    // Design problem template - for data structure design problems
    // Example: LRU Cache
    // Key differences: Custom class name, multiple methods, complex test setup
    // NOTE: PascalCase naming - keep acronyms/Roman numerals ALL CAPS (LRUCache, ReverseLinkedListII)

    // === PROBLEM IDENTIFICATION ===
    problem_name: "lru_cache", // snake_case: used for directory/file names
    solution_class_name: "LRUCache", // IMPORTANT: Custom class name for design problems
    problem_number: "146", // LeetCode problem number as string
    problem_title: "LRU Cache", // Exact title from LeetCode
    difficulty: "Medium", // Easy, Medium, Hard
    topics: "Hash Table, Linked List, Design, Doubly-Linked List", // Design-related topics
    tags: ["grind-75"], // Optional: common problem set tags

    // === README CONTENT ===
    // IMPORTANT: Preserve rich HTML content from LeetCode including:
    // - Code snippets with backticks: `code`
    // - Bold text: **bold** or <strong>bold</strong>
    // - Italic text: *italic* or <em>italic</em>
    // - Images: <img> tags with proper src and styling
    // - HTML formatting: <p>, <br>, <ul>, <li>, etc.
    // - Mathematical expressions and special characters
    readme_description: "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\\n\\nImplement the `LRUCache` class:\\n\\n- `LRUCache(int capacity)` Initialize the LRU cache with positive size capacity\\n- `int get(int key)` Return the value of the key if the key exists, otherwise return -1\\n- `void put(int key, int value)` Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key\\n\\nThe functions `get` and `put` must each run in `O(1)` average time complexity.",

    readme_examples: [
        {
            // Design problems often have complex operation sequences
            content: '```\\nInput\\n[\\"LRUCache\\", \\"put\\", \\"put\\", \\"get\\", \\"put\\", \\"get\\", \\"put\\", \\"get\\", \\"get\\", \\"get\\"]\\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\\nOutput\\n[null, null, null, 1, null, -1, null, -1, 3, 4]\\n\\nExplanation\\nLRUCache lRUCache = new LRUCache(2);\\nlRUCache.put(1, 1); // cache is {1=1}\\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\\nlRUCache.get(1);    // return 1\\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\\nlRUCache.get(2);    // returns -1 (not found)\\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\\nlRUCache.get(1);    // return -1 (not found)\\nlRUCache.get(3);    // return 3\\nlRUCache.get(4);    // return 4\\n```',
        },
    ],

    readme_constraints: "- 1 <= capacity <= 3000\\n- 0 <= key <= 10^4\\n- 0 <= value <= 10^5\\n- At most 2 * 10^5 calls will be made to get and put",
    readme_additional: "",

    // === SOLUTION TEMPLATE ===
    solution_imports: "", // Usually empty for design problems
    // IMPORTANT: Design problems have multiple methods including __init__
    solution_methods: [
        {
            name: "__init__", // Constructor method
            parameters: "capacity: int", // Constructor parameters
            return_type: "None", // Constructor returns None
            dummy_return: "", // Empty for None return
        },
        {
            name: "get", // Instance method
            parameters: "key: int",
            return_type: "int",
            dummy_return: "-1", // Specific default for this method
        },
        {
            name: "put", // Instance method
            parameters: "key: int, value: int",
            return_type: "None",
            dummy_return: "", // Empty for None return
        },
    ],

    // === TEST CONFIGURATION ===
    // IMPORTANT: Design problems import the custom class, not Solution
    test_imports: "import pytest\nfrom leetcode_py.test_utils import logged_test\nfrom .solution import LRUCache",
    test_class_name: "LRUCache", // PascalCase: TestClassName for pytest class
    test_helper_methods: [], // Often empty for design problems
    test_methods: [
        {
            name: "test_lru_cache",
            // IMPORTANT: Design tests use operations, inputs, expected pattern
            parametrize: "operations, inputs, expected",
            parametrize_typed: "operations: list[str], inputs: list[list[int]], expected: list[int | None]",
            test_cases: '[(["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]], [None, None, None, 1, None, -1, None, -1, 3, 4])]',
            // IMPORTANT: Complex test body that executes operation sequences
            body: 'cache: LRUCache | None = None\nresults: list[int | None] = []\nfor i, op in enumerate(operations):\n    if op == "LRUCache":\n        cache = LRUCache(inputs[i][0])\n        results.append(None)\n    elif op == "get" and cache is not None:\n        results.append(cache.get(inputs[i][0]))\n    elif op == "put" and cache is not None:\n        cache.put(inputs[i][0], inputs[i][1])\n        results.append(None)\nassert results == expected',
        },
    ],

    // === PLAYGROUND NOTEBOOK ===
    // IMPORTANT: Design playground uses operation sequences like tests
    playground_imports: "from solution import LRUCache",
    playground_test_case: "# Example test case\noperations = ['LRUCache', 'put', 'put', 'get', 'put', 'get', 'put', 'get', 'get', 'get']\ninputs = [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nexpected = [None, None, None, 1, None, -1, None, -1, 3, 4]",
    playground_execution: "cache = None\nresults: list[int | None] = []\nfor i, op in enumerate(operations):\n    if op == 'LRUCache':\n        cache = LRUCache(inputs[i][0])\n        results.append(None)\n    elif op == 'get' and cache is not None:\n        results.append(cache.get(inputs[i][0]))\n    elif op == 'put' and cache is not None:\n        cache.put(inputs[i][0], inputs[i][1])\n        results.append(None)\nresults",
    playground_assertion: "assert results == expected",
}
