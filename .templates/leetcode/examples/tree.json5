{
    // Tree problem template - for binary tree problems
    // Example: Invert Binary Tree
    // Key differences: TreeNode imports, tree-specific test setup

    // === PROBLEM IDENTIFICATION ===
    problem_name: "invert_binary_tree", // snake_case: used for directory/file names
    solution_class_name: "Solution", // Always "Solution" for algorithm problems
    problem_number: "226", // LeetCode problem number as string
    problem_title: "Invert Binary Tree", // Exact title from LeetCode
    difficulty: "Easy", // Easy, Medium, Hard
    topics: "Tree, Depth-First Search, Breadth-First Search, Binary Tree", // Tree-related topics
    tags: ["grind-75"], // Optional: common problem set tags

    // === README CONTENT ===
    // IMPORTANT: Preserve rich HTML content from LeetCode including:
    // - Code snippets with backticks: `code`
    // - Bold text: **bold** or <strong>bold</strong>
    // - Italic text: *italic* or <em>italic</em>
    // - Images: <img> tags with proper src and styling
    // - HTML formatting: <p>, <br>, <ul>, <li>, etc.
    // - Mathematical expressions and special characters
    readme_description: "Given the `root` of a binary tree, invert the tree, and return its root.",

    readme_examples: [
        {
            // Tree problems often have visual examples with images
            content: "```\nInput: root = [4,2,7,1,3,6,9]\nOutput: [4,7,2,9,6,3,1]\n```",
        },
        {
            content: "```\nInput: root = [2,1,3]\nOutput: [2,3,1]\n```",
        },
        {
            content: "```\nInput: root = []\nOutput: []\n```",
        },
    ],

    readme_constraints: "- The number of nodes in the tree is in the range [0, 100]\n- -100 <= Node.val <= 100",
    readme_additional: "",

    // === SOLUTION TEMPLATE ===
    // IMPORTANT: Tree problems need TreeNode import
    solution_imports: "from leetcode_py import TreeNode",
    solution_methods: [
        {
            name: "invert_tree", // snake_case method name
            parameters: "root: TreeNode | None", // Use TreeNode | None for nullable tree parameters
            return_type: "TreeNode | None", // Modern union syntax (not Optional[TreeNode])
            dummy_return: "None", // None for tree problems
        },
    ],

    // === TEST CONFIGURATION ===
    // IMPORTANT: Tree tests need TreeNode import and special test setup
    test_imports: "import pytest\n\nfrom leetcode_py import TreeNode\nfrom leetcode_py.test_utils import logged_test\n\nfrom .solution import Solution",
    test_class_name: "InvertBinaryTree",               // PascalCase: TestClassName for pytest class
    test_helper_methods: [
        {
            name: "setup_method",
            parameters: "",
            body: "self.solution = Solution()",
        },
    ],
    test_methods: [
        {
            name: "test_invert_tree",
            parametrize: "root_list, expected_list", // Use *_list naming for tree array inputs
            parametrize_typed: "root_list: list[int | None], expected_list: list[int | None]",
            test_cases: "[([4, 2, 7, 1, 3, 6, 9], [4, 7, 2, 9, 6, 3, 1]), ([2, 1, 3], [2, 3, 1]), ([], [])]",
            // IMPORTANT: Tree test body converts arrays to TreeNode and compares objects directly
            body: "root = TreeNode.from_list(root_list)\nexpected = TreeNode.from_list(expected_list)\nresult = self.solution.invert_tree(root)\nassert result == expected",
        },
    ],

    // === PLAYGROUND NOTEBOOK ===
    // IMPORTANT: Tree playground needs TreeNode import and conversion
    playground_imports: "from solution import Solution\n\nfrom leetcode_py import TreeNode",
    playground_test_case: "# Example test case\nroot_list: list[int | None] = [4, 2, 7, 1, 3, 6, 9]\nroot = TreeNode.from_list(root_list)\nexpected = TreeNode.from_list([4, 7, 2, 9, 6, 3, 1])",
    playground_execution: "result = Solution().invert_tree(root)\nresult",
    playground_assertion: "assert result == expected",
}
