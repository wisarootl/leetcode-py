{
    "problem_name": "lowest_common_ancestor_of_a_binary_search_tree",
    "solution_class_name": "Solution",
    "problem_number": "235",
    "problem_title": "Lowest Common Ancestor of a Binary Search Tree",
    "difficulty": "Medium",
    "topics": "Tree, Depth-First Search, Binary Search Tree, Binary Tree",
    "tags": ["grind-75"],
    "readme_description": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\n\nAccording to the definition of LCA on Wikipedia: \"The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).\"",
    "readme_examples": [
        {
            "content": "![Example 1](https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png)\n\n```\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\nOutput: 6\n```\n**Explanation:** The LCA of nodes 2 and 8 is 6."
        },
        {
            "content": "![Example 2](https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png)\n\n```\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\nOutput: 2\n```\n**Explanation:** The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition."
        },
        { "content": "```\nInput: root = [2,1], p = 2, q = 1\nOutput: 2\n```" }
    ],
    "readme_constraints": "- The number of nodes in the tree is in the range `[2, 10^5]`.\n- `-10^9 <= Node.val <= 10^9`\n- All `Node.val` are **unique**.\n- `p != q`\n- `p` and `q` will exist in the BST.",
    "readme_additional": "",
    "solution_imports": "from leetcode_py import TreeNode",
    "solution_methods": [
        {
            "name": "lowest_common_ancestor",
            "parameters": "root: TreeNode[int] | None, p: TreeNode[int], q: TreeNode[int]",
            "return_type": "TreeNode[int] | None",
            "dummy_return": "None"
        }
    ],
    "test_imports": "import pytest\nfrom leetcode_py import TreeNode\nfrom leetcode_py.test_utils import logged_test\nfrom .solution import Solution",
    "test_class_name": "LowestCommonAncestorOfABinarySearchTree",
    "test_helper_methods": [
        { "name": "setup_method", "parameters": "", "body": "self.solution = Solution()" },
        {
            "name": "_find_node",
            "parameters": "root: TreeNode[int], val: int",
            "body": "if not root:\n    return None\nif root.val == val:\n    return root\nleft = self._find_node(root.left, val)\nif left:\n    return left\nreturn self._find_node(root.right, val)"
        }
    ],
    "test_methods": [
        {
            "name": "test_lowest_common_ancestor",
            "parametrize": "root_list, p_val, q_val, expected_val",
            "parametrize_typed": "root_list: list[int | None], p_val: int, q_val: int, expected_val: int",
            "test_cases": "[([6, 2, 8, 0, 4, 7, 9, None, None, 3, 5], 2, 8, 6), ([6, 2, 8, 0, 4, 7, 9, None, None, 3, 5], 2, 4, 2), ([2, 1], 2, 1, 2), ([2, 1], 1, 2, 2), ([6, 2, 8, 0, 4, 7, 9], 0, 4, 2), ([6, 2, 8, 0, 4, 7, 9], 7, 9, 8)]",
            "body": "root = TreeNode[int].from_list(root_list)\nassert root is not None\np = self._find_node(root, p_val)\nq = self._find_node(root, q_val)\nassert p is not None and q is not None\nresult = self.solution.lowest_common_ancestor(root, p, q)\nassert result is not None\nassert result.val == expected_val"
        }
    ],
    "playground_imports": "from leetcode_py import TreeNode\nfrom solution import Solution",
    "playground_test_case": "# Example test case\nroot_list = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\np_val = 2\nq_val = 8\nexpected_val = 6",
    "playground_execution": "root = TreeNode[int].from_list(root_list)\np = find_node(root, p_val)\nq = find_node(root, q_val)\nresult = Solution().lowest_common_ancestor(root, p, q)\nresult.val if result else None",
    "playground_assertion": "assert result and result.val == expected_val"
}
