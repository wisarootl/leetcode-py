{
    "problem_name": "lru_cache",
    "solution_class_name": "LRUCache",
    "problem_number": "146",
    "problem_title": "LRU Cache",
    "difficulty": "Medium",
    "topics": "Hash Table, Linked List, Design, Doubly-Linked List",
    "tags": ["grind-75"],
    "readme_description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n\nImplement the `LRUCache` class:\n\n- `LRUCache(int capacity)` Initialize the LRU cache with positive size capacity\n- `int get(int key)` Return the value of the key if the key exists, otherwise return -1\n- `void put(int key, int value)` Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key\n\nThe functions `get` and `put` must each run in `O(1)` average time complexity.",
    "readme_examples": [
        {
            "content": "```\nInput\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n```"
        }
    ],
    "readme_constraints": "- 1 <= capacity <= 3000\n- 0 <= key <= 10^4\n- 0 <= value <= 10^5\n- At most 2 * 10^5 calls will be made to get and put",
    "readme_additional": "",
    "solution_imports": "",
    "solution_methods": [
        { "name": "__init__", "parameters": "capacity: int", "return_type": "None", "dummy_return": "" },
        { "name": "get", "parameters": "key: int", "return_type": "int", "dummy_return": "-1" },
        {
            "name": "put",
            "parameters": "key: int, value: int",
            "return_type": "None",
            "dummy_return": ""
        }
    ],
    "test_imports": "import pytest\nfrom leetcode_py.test_utils import logged_test\nfrom .solution import LRUCache",
    "test_class_name": "LRUCache",
    "test_helper_methods": [],
    "test_methods": [
        {
            "name": "test_lru_cache",
            "parametrize": "operations, inputs, expected",
            "parametrize_typed": "operations: list[str], inputs: list[list[int]], expected: list[int | None]",
            "test_cases": "[([\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]], [None, None, None, 1, None, -1, None, -1, 3, 4])]",
            "body": "cache: LRUCache | None = None\nresults: list[int | None] = []\nfor i, op in enumerate(operations):\n    if op == \"LRUCache\":\n        cache = LRUCache(inputs[i][0])\n        results.append(None)\n    elif op == \"get\" and cache is not None:\n        results.append(cache.get(inputs[i][0]))\n    elif op == \"put\" and cache is not None:\n        cache.put(inputs[i][0], inputs[i][1])\n        results.append(None)\nassert results == expected"
        }
    ],
    "playground_imports": "from solution import LRUCache",
    "playground_test_case": "# Example test case\noperations = ['LRUCache', 'put', 'put', 'get', 'put', 'get', 'put', 'get', 'get', 'get']\ninputs = [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nexpected = [None, None, None, 1, None, -1, None, -1, 3, 4]",
    "playground_execution": "cache = None\nresults: list[int | None] = []\nfor i, op in enumerate(operations):\n    if op == 'LRUCache':\n        cache = LRUCache(inputs[i][0])\n        results.append(None)\n    elif op == 'get' and cache is not None:\n        results.append(cache.get(inputs[i][0]))\n    elif op == 'put' and cache is not None:\n        cache.put(inputs[i][0], inputs[i][1])\n        results.append(None)\nresults",
    "playground_assertion": "assert results == expected"
}
