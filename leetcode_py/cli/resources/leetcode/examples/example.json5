{
  // ============================================================================
  // COMPREHENSIVE LEETCODE TEMPLATE EXAMPLE
  // ============================================================================
  // This example demonstrates ALL template patterns using valid_anagram as base
  // with comprehensive comments showing variations for different problem types.
  //
  // REFERENCE PROBLEMS (see .templates/leetcode/json/ for complete examples):
  // 1. valid_anagram        - Basic: string parameters, boolean return
  // 2. invert_binary_tree   - Tree: TreeNode imports/parameters
  // 3. merge_two_sorted_lists - LinkedList: ListNode imports/parameters
  // 4. lru_cache           - Design: custom class, multiple methods, operations
  // 5. implement_trie_prefix_tree - Trie: DictTree inheritance
  // ============================================================================

  // === PROBLEM IDENTIFICATION ===
  "problem_name": "valid_anagram",                    // snake_case: used for directory/file names
  "solution_class_name": "Solution",                  // "Solution" for basic problems
                                                     // "LRUCache" for design problems
                                                     // "Trie(DictTree[str])" for inheritance
  "problem_number": "242",                           // LeetCode problem number as string
  "problem_title": "Valid Anagram",                  // Exact title from LeetCode
  "difficulty": "Easy",                              // Easy, Medium, Hard
  "topics": "Hash Table, String, Sorting",          // Comma-separated topics from LeetCode
  "_tags": { "list": ["grind-75"] },                // Optional: common problem set tags
                                                     // Use _tags wrapper for cookiecutter lists

  // === README CONTENT ===
  // IMPORTANT: Preserve rich HTML content from LeetCode including:
  // - Code snippets with backticks: `code`
  // - Bold text: **bold** or <strong>bold</strong>
  // - Italic text: *italic* or <em>italic</em>
  // - Images: ![Example](https://assets.leetcode.com/uploads/...)
  // - HTML formatting: <p>, <br>, <ul>, <li>, etc.
  // - Mathematical expressions and special characters
  "readme_description": "Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise.",

  "_readme_examples": {                              // Use _readme_examples wrapper for cookiecutter lists
    "list": [
      { "content": "```\nInput: s = \"anagram\", t = \"nagaram\"\nOutput: true\n```" },
      { "content": "```\nInput: s = \"rat\", t = \"car\"\nOutput: false\n```" }
      // For tree problems: Include images
      // { "content": "![Example 1](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)\n\n```\nInput: root = [4,2,7,1,3,6,9]\nOutput: [4,7,2,9,6,3,1]\n```" }
    ]
  },

  "readme_constraints": "- 1 <= s.length, t.length <= 5 * 10^4\n- s and t consist of lowercase English letters.",
  "readme_additional": "**Follow up:** What if the inputs contain Unicode characters? How would you adapt your solution to such a case?",

  // === HELPER FUNCTIONS ===
  // New template system uses helper functions for cleaner test organization
  "helpers_imports": "",                             // Empty for basic problems
                                                     // "from leetcode_py import TreeNode" for tree problems
                                                     // "from leetcode_py import ListNode" for linked list problems
  "helpers_content": "",                             // Additional helper content if needed
  "helpers_run_name": "is_anagram",                  // Function name matching main method
  "helpers_run_signature": "(solution_class: type, s: str, t: str)",
                                                     // For tree: "(solution_class: type, root_list: list[int | None])"
                                                     // For linked list: "(solution_class: type, list1_vals: list[int], list2_vals: list[int])"
                                                     // For design: "(solution_class: type, operations: list[str], inputs: list[list[int]])"
  "helpers_run_body": "    implementation = solution_class()\n    return implementation.is_anagram(s, t)",
                                                     // For tree: "    root = TreeNode[int].from_list(root_list)\n    implementation = solution_class()\n    return implementation.invert_tree(root)"
                                                     // For design: "    cache = None\n    results: list[int | None] = []\n    # ... operation loop ...\n    return results, cache"
  "helpers_assert_name": "is_anagram",              // Function name matching main method
  "helpers_assert_signature": "(result: bool, expected: bool) -> bool",
                                                     // For tree: "(result: TreeNode[int] | None, expected_list: list[int | None]) -> bool"
                                                     // For design: "(result: list[int | None], expected: list[int | None]) -> bool"
  "helpers_assert_body": "    assert result == expected\n    return True",
                                                     // For tree: "    expected = TreeNode[int].from_list(expected_list)\n    assert result == expected\n    return True"

  // === SOLUTION TEMPLATE ===
  "solution_imports": "",                            // Empty for basic problems
                                                     // "from leetcode_py import TreeNode" for tree problems
                                                     // "from leetcode_py import ListNode" for linked list problems
                                                     // "from leetcode_py.data_structures import DictTree, RecursiveDict" for trie problems
  "solution_contents": "",                           // Additional content before class definition
  "solution_class_content": "",                      // Content inside class definition (usually empty)

  // === TEST CONFIGURATION ===
  "test_imports": "import pytest\nfrom leetcode_py.test_utils import logged_test\nfrom .helpers import assert_is_anagram, run_is_anagram\nfrom .solution import Solution",
                                                     // For design: "from .solution import LRUCache" instead of Solution
  "test_content": "",                                // Additional test content
  "test_class_name": "ValidAnagram",                 // PascalCase: TestClassName for pytest class
  "test_class_content": "    def setup_method(self):\n        self.solution = Solution()",
                                                     // Empty for design problems: ""

  // === SOLUTION METHODS ===
  "_solution_methods": {                             // Use _solution_methods wrapper for cookiecutter lists
    "list": [
      {
        "name": "is_anagram",                        // snake_case method name
        "signature": "(self, s: str, t: str) -> bool", // Full method signature with type hints
                                                     // For tree: "(self, root: TreeNode[int] | None) -> TreeNode[int] | None"
                                                     // For linked list: "(self, list1: ListNode[int] | None, list2: ListNode[int] | None) -> ListNode[int] | None"
        "body": "        # TODO: Implement is_anagram\n        return False"
                                                     // For design problems with __init__:
                                                     // { "name": "__init__", "signature": "(self, capacity: int) -> None", "body": "        # TODO: Initialize\n        pass" }
      }
    ]
  },

  // === TEST HELPER METHODS ===
  "_test_helper_methods": {                          // Use _test_helper_methods wrapper for cookiecutter lists
    "list": [
      { "name": "setup_method", "parameters": "", "body": "self.solution = Solution()" }
                                                     // Empty list for design problems: []
    ]
  },

  // === TEST METHODS ===
  "_test_methods": {                                 // Use _test_methods wrapper for cookiecutter lists
    "list": [
      {
        "name": "test_is_anagram",                   // test_{method_name}
        "signature": "(self, s: str, t: str, expected: bool)", // Method signature with type hints
        "parametrize": "s, t, expected",             // pytest parametrize parameters
                                                     // For tree: "root_list, expected_list"
                                                     // For design: "operations, inputs, expected"
        "test_cases": "[('anagram', 'nagaram', True), ('rat', 'car', False), ('listen', 'silent', True), ('hello', 'bello', False), ('', '', True), ('a', 'a', True), ('a', 'b', False), ('ab', 'ba', True), ('abc', 'bca', True), ('abc', 'def', False), ('aab', 'abb', False), ('aabbcc', 'abcabc', True), ('abcd', 'abcde', False), ('race', 'care', True), ('elbow', 'below', True), ('study', 'dusty', True), ('night', 'thing', True), ('stressed', 'desserts', True)]",
                                                     // For tree: "[([4, 2, 7, 1, 3, 6, 9], [4, 7, 2, 9, 6, 3, 1]), ([2, 1, 3], [2, 3, 1]), ([], [])]"
                                                     // For design: "[(['LRUCache', 'put', 'get'], [[2], [1, 1], [1]], [None, None, 1])]"
        "body": "        result = run_is_anagram(Solution, s, t)\n        assert_is_anagram(result, expected)"
                                                     // For tree: "        result = run_invert_tree(Solution, root_list)\n        assert_invert_tree(result, expected_list)"
                                                     // For design: "        result, _ = run_lru_cache(LRUCache, operations, inputs)\n        assert_lru_cache(result, expected)"
      }
    ]
  },

  // === PLAYGROUND NOTEBOOK ===
  // CRITICAL: Use single quotes for Python strings to avoid JSON escaping issues with Jupyter notebooks
  // Double quotes in JSON + cookiecutter + Jupyter notebook = triple escaping issues
  // ALWAYS use single quotes: s = 'hello', not s = "hello"
  "playground_imports": "from helpers import run_is_anagram, assert_is_anagram\nfrom solution import Solution",
                                                     // For tree: "from helpers import run_invert_tree, assert_invert_tree\nfrom solution import Solution\nfrom leetcode_py import TreeNode"
                                                     // For design: "from helpers import run_lru_cache, assert_lru_cache\nfrom solution import LRUCache"
  "playground_setup": "# Example test case\ns = 'anagram'\nt = 'nagaram'\nexpected = True",
                                                     // For tree: "# Example test case\nroot_list: list[int | None] = [4, 2, 7, 1, 3, 6, 9]\nexpected_list: list[int | None] = [4, 7, 2, 9, 6, 3, 1]"
                                                     // For design: "# Example test case\noperations = ['LRUCache', 'put', 'get']\ninputs = [[2], [1, 1], [1]]\nexpected = [None, None, 1]"
  "playground_run": "result = run_is_anagram(Solution, s, t)\nresult",
                                                     // For tree: "result = run_invert_tree(Solution, root_list)\nresult"
                                                     // For design: "result, cache = run_lru_cache(LRUCache, operations, inputs)\nprint(result)\ncache"
  "playground_assert": "assert_is_anagram(result, expected)"
                                                     // For tree: "assert_invert_tree(result, expected_list)"
                                                     // For design: "assert_lru_cache(result, expected)"

  // ============================================================================
  // PROBLEM TYPE VARIATIONS SUMMARY:
  // ============================================================================
  //
  // BASIC PROBLEMS (valid_anagram):
  // - solution_class_name: "Solution"
  // - solution_imports: ""
  // - Simple method signatures: "(self, s: str, t: str) -> bool"
  // - Basic test cases: string/number parameters
  // - Playground: single quotes for strings
  //
  // TREE PROBLEMS (invert_binary_tree):
  // - solution_class_name: "Solution"
  // - solution_imports: "from leetcode_py import TreeNode"
  // - Tree method signatures: "(self, root: TreeNode[int] | None) -> TreeNode[int] | None"
  // - Helper functions use TreeNode.from_list()
  // - Test cases: list representations of trees
  // - Playground: TreeNode imports and list conversions
  //
  // LINKED LIST PROBLEMS (merge_two_sorted_lists):
  // - solution_class_name: "Solution"
  // - solution_imports: "from leetcode_py import ListNode"
  // - List method signatures: "(self, list1: ListNode[int] | None, list2: ListNode[int] | None) -> ListNode[int] | None"
  // - Helper functions use ListNode.from_list()
  // - Test cases: list representations of linked lists
  // - Playground: ListNode imports and list conversions
  //
  // DESIGN PROBLEMS (lru_cache):
  // - solution_class_name: "LRUCache" (custom class name)
  // - Multiple methods including __init__
  // - Operations-based testing: operations, inputs, expected arrays
  // - Complex test body with operation loops
  // - Helper functions return (results, instance) for debugging
  // - Playground: print results, return instance
  // - test_class_content: "" (no setup_method)
  //
  // INHERITANCE PROBLEMS (implement_trie_prefix_tree):
  // - solution_class_name: "Trie(DictTree[str])" (with inheritance)
  // - solution_imports: "from leetcode_py.data_structures import DictTree, RecursiveDict"
  // - Custom class with inheritance from DictTree
  // - Operations-based testing like design problems
  // - Helper functions return (results, instance) for debugging
  //
  // MULTIPLE SOLUTIONS (invert_binary_tree, lru_cache):
  // - Add parametrize for solution classes in test files:
  //   @pytest.mark.parametrize("solution_class", [Solution, SolutionDFS, SolutionBFS])
  //   @pytest.mark.parametrize("solution_class", [LRUCache, LRUCacheWithDoublyList])
  // - Update test method signature to include solution_class parameter
  // - Import all solution classes in test file
  // ============================================================================
}
