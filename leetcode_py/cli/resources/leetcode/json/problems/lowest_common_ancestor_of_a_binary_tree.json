{
    "problem_name": "lowest_common_ancestor_of_a_binary_tree",
    "solution_class_name": "Solution",
    "problem_number": "236",
    "problem_title": "Lowest Common Ancestor of a Binary Tree",
    "difficulty": "Medium",
    "topics": "Tree, Depth-First Search, Binary Tree",
    "_tags": { "list": ["grind-75"] },
    "readme_description": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\n\nAccording to the definition of LCA on Wikipedia: \"The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).\"",
    "_readme_examples": {
        "list": [
            {
                "content": "<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" />\n\n```\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\nOutput: 3\nExplanation: The LCA of nodes 5 and 1 is 3.\n```"
            },
            {
                "content": "<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" />\n\n```\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\nOutput: 5\nExplanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n```"
            },
            { "content": "```\nInput: root = [1,2], p = 1, q = 2\nOutput: 1\n```" }
        ]
    },
    "readme_constraints": "- The number of nodes in the tree is in the range [2, 10^5].\n- -10^9 <= Node.val <= 10^9\n- All Node.val are unique.\n- p != q\n- p and q will exist in the tree.",
    "readme_additional": "",
    "helpers_imports": "from leetcode_py import TreeNode",
    "helpers_content": "",
    "helpers_run_name": "lowest_common_ancestor",
    "helpers_run_signature": "(solution_class: type, root_list: list[int | None], p_val: int, q_val: int)",
    "helpers_run_body": "    root = TreeNode[int].from_list(root_list)\n    assert root is not None\n    p = root.find_node(p_val)\n    q = root.find_node(q_val)\n    assert p is not None and q is not None\n    implementation = solution_class()\n    return implementation.lowest_common_ancestor(root, p, q)",
    "helpers_assert_name": "lowest_common_ancestor",
    "helpers_assert_signature": "(result: TreeNode[int], expected_val: int) -> bool",
    "helpers_assert_body": "    assert result.val == expected_val\n    return True",
    "solution_imports": "from leetcode_py import TreeNode",
    "solution_contents": "",
    "solution_class_content": "",
    "test_imports": "import pytest\nfrom leetcode_py import logged_test\nfrom .helpers import assert_lowest_common_ancestor, run_lowest_common_ancestor\nfrom .solution import Solution",
    "test_content": "",
    "test_class_name": "LowestCommonAncestorOfABinaryTree",
    "test_class_content": "    def setup_method(self):\n        self.solution = Solution()",
    "_solution_methods": {
        "list": [
            {
                "name": "lowest_common_ancestor",
                "signature": "(self, root: TreeNode[int], p: TreeNode[int], q: TreeNode[int]) -> TreeNode[int]",
                "body": "        # TODO: Implement lowest_common_ancestor\n        return root"
            }
        ]
    },
    "_test_helper_methods": {
        "list": [{ "name": "setup_method", "parameters": "", "body": "self.solution = Solution()" }]
    },
    "_test_methods": {
        "list": [
            {
                "name": "test_lowest_common_ancestor",
                "signature": "(self, root_list: list[int | None], p_val: int, q_val: int, expected_val: int)",
                "parametrize": "root_list, p_val, q_val, expected_val",
                "test_cases": "[([3,5,1,6,2,0,8,None,None,7,4], 5, 1, 3), ([3,5,1,6,2,0,8,None,None,7,4], 5, 4, 5), ([1,2], 1, 2, 1), ([2,1], 2, 1, 2), ([3,5,1,6,2,0,8,None,None,7,4], 6, 7, 5), ([3,5,1,6,2,0,8,None,None,7,4], 0, 8, 1), ([1, None, 2, None, 3], 2, 3, 2), ([4, 2, 6, 1, 3, 5, 7], 1, 7, 4), ([10, 5, 15, 3, 7, None, 18], 3, 7, 5), ([1, 2, 3, 4, 5, 6, 7], 4, 5, 2), ([20, 8, 22, 4, 12, None, 25], 4, 12, 8), ([50, 30, 70, 20, 40, 60, 80], 20, 40, 30)]",
                "body": "        result = run_lowest_common_ancestor(Solution, root_list, p_val, q_val)\n        assert_lowest_common_ancestor(result, expected_val)"
            }
        ]
    },
    "playground_imports": "from helpers import run_lowest_common_ancestor, assert_lowest_common_ancestor\nfrom solution import Solution\nfrom leetcode_py import TreeNode",
    "playground_setup": "# Example test case\nroot_list = [3,5,1,6,2,0,8,None,None,7,4]\np_val = 5\nq_val = 1\nexpected_val = 3",
    "playground_run": "result = run_lowest_common_ancestor(Solution, root_list, p_val, q_val)\nresult.val",
    "playground_assert": "assert_lowest_common_ancestor(result, expected_val)"
}
